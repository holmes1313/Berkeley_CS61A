# -*- coding: utf-8 -*-
"""
Created on Sun Jun 16 10:44:48 2019

@author: z.chen7
"""

# Non-local assigment and persistent local state
def make_with_draw(balance):
    """Return a withdraw function with a starting balance."""
    def withdraw(amount):
        nonlocal balance  # declare the name balance nonlocal at the top of the body of the function in which it is reassigned
        if amount > balance:
            return 'Insufficient funds'
        balance = balance - amount  # re-bind balance in the first non-local frame in which it was bound previously
        return balance
    return withdraw


withdraw = make_with_draw(100)
withdraw(50)


# the effect of nonlocal statements
"""
Effect: furture assignments to that name change its pre-existing binding in 
the first non-local frame (Python Docs: an 'enclosing scope') of the current
environment in which that name is bound.

From the Python 3 language reference:
    Names listed in a nonlocal statement myst refer to pre-existing bindings
    in an enclosing scope.
    
    Names listed in a nonlocal statement must not collide with pre-existing
    bindings in the local scope.
"""


# the many mennings of assigment statements
"""
x = 2

status:
    nonlocal x
    x is bound in a non-local frame
effect:
    re-bind x to 2 in the first non-local frame fo the current environment
    in which it is bound
    
status:
    nonlocal x
    x is not bound in a non-local frame
effect:
    SyntaxError: no binding for nonlocal x found
    
status:
    nonlocal x
    x is bound in a non-local frame
    x is also bound locally
effect:
    SyntaxError: name x is parameter and nonlocal.

X must be already bound and X cannot be bound in the current frame."""


# Python Particulars
"""
Python pre-computes which frame contains each name before executing the body of a function.

Within the body of a function, all instances of a name must refer to the same frame.
"""


# Mutable value & presistent local state
# mutable values can be changed without a nonlocal statement

def make_withdraw_list(balance):
    b = [balance]
    def withdraw(amount):
        if amount > b[0]:
            return 'Insufficient funds'
        b[0] = b[0] - amount
        return b[0]
    return withdraw

withdraw = make_withdraw_list(100)
withdraw(30)



def f(x):
    x = 4
    def g(y):
        def h(z):
            nonlocal x
            x = x + 1
            return x + y + z
        return h
    return g

a = f(1)
b = a(2)
b(3)  # 10, nonlocal x = 5
b(3)  # 11, nonlocal x = 6



# Lab 5
# Trees
"""
A tree is a data structure that represents a hierachy of information. A file system
is a good example of a tree structure.
    root: the node at the top of the tree
    label: the value in a node, selected by the label function
    branches: a list of trees directly under the tree's root, selected by the 
branches function
    leaf: a tree with zero branches
    node: any location within the tree (e.g. root node, leaf node, etc)
    
Our tree abstract data typpe consists of a root and a list of its branches.
To create a tree and access its root value and branches, use the following 
constructor and selectors:
    Constructor:
        tree(label, branches=[]): create a tree object with the given label
        value at its root node and list of branches.
    Selectors:
        label(tree): returns the value in the root node of tree
        branches(tree): returns the list of branches of the given tree
    Convenience function:
        is_leaf(tree): returns True if tree's list of branches is empty and False otherwise.

For example, the tree generated by
    number_tree = tree(1, 
                       [tree(2),
                        tree(3, 
                             [tree(4),
                              tree(5)]),
                        tree(6,
                             [tree(7)])
                       ])
   
To extract the number 3 from this tree, which is the label of the root of its
second branch:
    label(branches(number_tree)[0])

"""



# Iterators
"""
A container can provide an iterator that provides access to its elements in order

iter(iterable): return an iterator over the elements of an iterable value
next(iterator): return the next element in an iterator
"""
s = [1, 2, 3]
i = iter(s)
next(i)
next(i)
list(i)
next(i)


# Dictionary Iterators
"""
An iterable value is any value that can be passed to iter to produce an iterator

An iterator is returned from iter and can be passed to next; all iterators are mutable

A dictionary, its keys, its values, and its items are all iterable values
"""

d = {'one': 1, "two": 2, "three": 3}
k = iter(d.keys())
next(k)

v = iter(d.values())
next(v)

i = iter(d.items())
next(i)

"""
If a dictionary changes its size, then u can't used any of the iterators
you've constucted instead you need to make it new ones."""
d = {'one': 1, 'two': 2}
k = iter(d)
next(k)
d['three'] = 3
next(k)   # RuntimeError: dictionary changed size during iteration

d = {'one': 1, 'two': 2}
k = iter(d.values())
next(k)
d['two'] = 3
next(k)


# for statement
"""
if I use an iterator in a for statement, I can still go through all of the elements until I reach
the end but that will advance the iterator so that I can't use it again."""
r = range(3, 6)
ri = iter(r)
for i in ri:
    print(i)

for i in ri:
    print(i)


# Built-in functions for iteration
"""
Many built-in Python sequence operations return iterators that computer results lazily:
    
            map(func, iterable):  Iterate over fun(x) for x in iterable
            
            filter(func, iterable): Iterate over x in iterable if func(x)
            
            zip(first_iter, second_iter): Iterate over co-indexed (x, y) pairs
            
            reversed(sequence): Iterate over x in a sequence in reverse order
            
To view the contents of an iterator, place the resulting elements into a container:
    
    list(iterator): Create a list containing all x in iterator
    
    tuple(iterator): Create a tuple containing all x in iterator
    
    sorted(iterator): Create a sorted list containing x in iterator
"""

bcd = ['b', 'c', 'd']
[x.upper() for x in bcd]

map(lambda x: x.upper(), bcd)
list(map(lambda x: x.upper(), bcd))

def double(x):
    print('**', x, '=>', 2*x, '**')
    return 2*x

m = map(double, [3, 5, 7])
next(m)
next(m)
next(m)
next(m)

m = map(double, range(3, 7))
f = lambda x: x >= 10
t = filter(f, m)
next(t)
next(t)
list(t)

list(filter(f, map(double, range(3, 7))))

t = [1, 2, 3, 2, 1]
reversed(t)
list(reversed(t)) == t

d = {'a': 1, 'b': 2}
items = zip(d.keys(), d.values())
items
dict(zip(d.keys(), d.values()))
list(zip(d, d.values()))


# Generators and Generator fuctions
"""
A generator function is a function that yields values instead of returning them

A normal function returns once; a generator function can yield multiple times

A generator is an iterator created automatically by calling a generator function

When a generator function is called, it returns a generator that iterates over its yields
"""

def evens(start, end):
    even = start + (start % 2)
    while even <= end:
        yield even
        even += 2

list(evens(1, 10))


# Generators can yield from iterators
"""
A yield from statement yields all values from an iterator or iterable"""

def a_then_b(a, b):
    yield from a
    yield from b
   
"""
def a_then_b(a, b):
    for x in a:
        yield x
    for y in b:
        yield y
"""
list(a_then_b([3, 4], [5, 6]))


def countdown_1(k):
    if k > 0:
        yield k
        yield countdown(k-1)
list(countdown_1(3))

def countdown_2(k):
    if k > 0:
        yield k
        for x in countdown_2(k-1):
            yield x
list(countdown_2(3))

def countdown_3(k):
    if k > 0:
        yield k
        yield from countdown_3(k-1)
list(countdown_3(3))


def prefixes(s):
    if s:
        yield from prefixes(s[:-1])
        yield s

list(prefixes('abc'))


def substrings(s):
    if s:
        yield from prefixes(s)
        yield from substrings(s[1:])
        
list(substrings('tops'))




"""
A class servers as a template for its instances.
And each object is an instance of some class."""